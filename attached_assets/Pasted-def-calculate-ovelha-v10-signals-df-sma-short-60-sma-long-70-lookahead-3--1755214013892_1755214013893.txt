def calculate_ovelha_v10_signals(
    df,
    sma_short=60,
    sma_long=70,
    lookahead=3,
    # ----- THRESHOLD -----
    use_dynamic_threshold=True,
    vol_factor=0.5,          # multiplicador do ATR_rel (ATR/close) para o threshold adaptativo
    threshold_fixed=0.0003,  # fallback caso use_dynamic_threshold=False
    # ----- HISTERese -----
    buffer=0.0015,
    # ----- RF -----
    n_estimators=200,
    max_depth=None,
    class_weight='balanced',   # ajuda no desbalanceamento das classes
    random_state=42
):
    """
    Calcula features, rotula com threshold (adaptativo ou fixo), treina RF, produz Signal/Estado.

    Retorna um DataFrame com colunas:
      - Features: RSI_14, RSL_20, ATR, ret_1, accel, decel, atr_norm
      - y (triclass: -1/0/1), y_bin (Â±1 ou NaN quando y=0)
      - thr_used (threshold por barra), future_ret
      - Signal_model (previsÃ£o RF em triclass), Signal_model_bin (Â±1 ou NaN)
      - Signal (apÃ³s filtro/histerese), Estado (persistÃªncia)
    """
    try:
        df_work = df.copy()

        # =======================
        # FEATURES
        # =======================
        df_work[f'SMA_{sma_short}'] = df_work['close'].rolling(window=sma_short).mean()
        df_work[f'SMA_{sma_long}']  = df_work['close'].rolling(window=sma_long).mean()
        df_work['SMA_20']           = df_work['close'].rolling(window=20).mean()

        # RSI(14)
        delta = df_work['close'].diff()
        gain = np.where(delta > 0, delta, 0.0)
        loss = np.where(delta < 0, -delta, 0.0)
        avg_gain = pd.Series(gain).rolling(window=14, min_periods=14).mean()
        avg_loss = pd.Series(loss).rolling(window=14, min_periods=14).mean()
        rs = avg_gain / avg_loss.replace(0, np.nan)
        df_work['RSI_14'] = 100 - (100 / (1 + rs))
        df_work['RSI_14'] = df_work['RSI_14'].bfill()

        # RSL(20)
        df_work['RSL_20'] = df_work['close'] / df_work['SMA_20']

        # ATR base (14)
        df_work['prior_close'] = df_work['close'].shift(1)
        df_work['tr1'] = df_work['high'] - df_work['low']
        df_work['tr2'] = (df_work['high'] - df_work['prior_close']).abs()
        df_work['tr3'] = (df_work['low'] - df_work['prior_close']).abs()
        df_work['TR']  = df_work[['tr1', 'tr2', 'tr3']].max(axis=1)
        df_work['ATR'] = df_work['TR'].rolling(window=14).mean()

        # ðŸ”¹ NOVAS FEATURES
        # ATR_7 (volatilidade recente, mais sensÃ­vel)
        df_work['ATR_7'] = df_work['TR'].rolling(window=7).mean()

        # Desvio padrÃ£o 20 dos retornos (ruÃ­do/aleatoriedade relativa)
        df_work['ret_1']     = df_work['close'].pct_change()
        df_work['stddev_20'] = df_work['ret_1'].rolling(window=20).std()

        # Slope da SMA longa (tendÃªncia/regime) - aprox. simples em janela 20
        _slope_w = 20
        sma_l = df_work[f'SMA_{sma_long}']
        df_work['slope_SMA_long'] = ((sma_l / sma_l.shift(_slope_w)) - 1) / _slope_w

        # MACD hist (12,26,9)
        ema12   = df_work['close'].ewm(span=12, adjust=False).mean()
        ema26   = df_work['close'].ewm(span=26, adjust=False).mean()
        macd    = ema12 - ema26
        signal  = macd.ewm(span=9, adjust=False).mean()
        df_work['MACD_hist'] = macd - signal

        # Derivadas e normalizaÃ§Ãµes jÃ¡ existentes
        df_work['accel']    = df_work['ret_1'].diff()
        df_work['decel']    = -df_work['accel']
        df_work['atr_norm'] = df_work['ATR'] / df_work['close']
        # ===== BUFFER ADAPTATIVO =====
        b = 0.8  # multiplicador inicial (tune na otimizaÃ§Ã£o)
        df_work['buffer_pct'] = b * (df_work['ATR'] / df_work['close'])  # ou b * df_work['atr_norm']

        # (opcional) limitar extremos
        df_work['buffer_pct'] = df_work['buffer_pct'].clip(lower=0.0002, upper=0.005)  # 0.02% a 0.5%



        # =======================
        # LABEL (y) COM THRESHOLD
        # =======================
        df_work['future_ret'] = df_work['close'].shift(-lookahead) / df_work['close'] - 1

        if use_dynamic_threshold:
            # threshold adaptativo: vol_factor * (ATR / close)
            df_work['thr_used'] = vol_factor * (df_work['ATR'] / df_work['close'])
        else:
            df_work['thr_used'] = float(threshold_fixed)

        df_work['y'] = 0
        df_work.loc[df_work['future_ret'] >  df_work['thr_used'], 'y'] =  1
        df_work.loc[df_work['future_ret'] < -df_work['thr_used'], 'y'] = -1

        # VersÃ£o binÃ¡ria (apenas onde hÃ¡ trade)
        df_work['y_bin'] = df_work['y'].replace({0: np.nan})

        # =======================
        # TREINO RF (triclass)
        # =======================
        features = ['RSI_14', 'RSL_20', 'ATR', 'ATR_7', 'stddev_20', 'slope_SMA_long', 'MACD_hist', 'ret_1', 'accel', 'decel', 'atr_norm']
        mask_feat = df_work[features].notna().all(axis=1) & df_work['y'].notna()
        X = df_work.loc[mask_feat, features]
        y = df_work.loc[mask_feat, 'y']

        # Verificar se temos dados suficientes para treinar
        if len(X) < 50:
            st.warning("âš ï¸ Dados insuficientes para treinar o modelo OVELHA V2. Usando modelo clÃ¡ssico.")
            return None

        rf = RandomForestClassifier(
            n_estimators=n_estimators,
            max_depth=max_depth,
            class_weight=class_weight,
            random_state=random_state,
            n_jobs=-1
        )
        rf.fit(X, y)

        # PrevisÃ£o (triclass)
        df_work['Signal_model'] = np.nan
        df_work.loc[mask_feat, 'Signal_model'] = rf.predict(X)

        # VersÃ£o binÃ¡ria da previsÃ£o (apenas Â±1; onde previu 0 vira NaN)
        df_work['Signal_model_bin'] = df_work['Signal_model'].replace({0: np.nan})

            # =======================
        # FILTRO DE TENDÃŠNCIA + HISTERESE (com buffer adaptativo)
        # =======================
        df_work['Signal'] = 'Stay Out'
        for i in range(1, len(df_work)):
            prev_estado = df_work['Signal'].iloc[i-1]
            price = df_work['close'].iloc[i]
            sma_s = df_work[f'SMA_{sma_short}'].iloc[i]
            sma_l = df_work[f'SMA_{sma_long}'].iloc[i]
            sm    = df_work['Signal_model'].iloc[i]
            buf   = df_work['buffer_pct'].iloc[i]  # <-- buffer dinÃ¢mico

            if sm == 1:
                if price > sma_s * (1 + buf) and price > sma_l * (1 + buf):
                    df_work.iat[i, df_work.columns.get_loc('Signal')] = 'Buy'
                else:
                    df_work.iat[i, df_work.columns.get_loc('Signal')] = prev_estado
            elif sm == -1:
                if price < sma_s * (1 - buf):
                    df_work.iat[i, df_work.columns.get_loc('Signal')] = 'Sell'
                else:
                    df_work.iat[i, df_work.columns.get_loc('Signal')] = prev_estado
            else:
                df_work.iat[i, df_work.columns.get_loc('Signal')] = prev_estado

        # PersistÃªncia de estado
        df_work['Estado'] = 'Stay Out'
        for i in range(1, len(df_work)):
            sig = df_work['Signal'].iloc[i]
            df_work.iat[i, df_work.columns.get_loc('Estado')] = sig if sig != 'Stay Out' else df_work['Estado'].iloc[i-1]

        return df_work

    	except Exception as e:
        st.error(f"Erro no modelo OVELHA V2: {str(e)}")
        return None
