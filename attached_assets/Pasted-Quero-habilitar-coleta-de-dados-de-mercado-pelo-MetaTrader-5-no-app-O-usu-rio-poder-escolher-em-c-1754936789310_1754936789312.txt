Quero habilitar coleta de dados de mercado pelo MetaTrader 5 no app. O usuário poderá escolher, em cada funcionalidade, qual base de dados usar (ex.: MT5 ou outra). Para a opção MetaTrader 5 (Python), siga exatamente as instruções e o template abaixo:

Requisitos

Ter o terminal do MetaTrader 5 instalado e logado em uma conta válida.

Biblioteca MetaTrader5 instalada (pip install MetaTrader5) e pandas, numpy.

O terminal MT5 deve estar aberto na mesma máquina do processo Python.

Convenções

Normalize colunas para: time, open, high, low, close, volume.

Ordene por time e defina time como índice quando fizer sentido.

Trate retornos vazios e erros com mensagens claras.

Permita dois modos:

Histórico por intervalo de datas (start, end)

Últimos N candles (útil para atualizar rapidamente o gráfico)

Template obrigatório (copiar/colar e usar como base):

python
Copiar
Editar
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from contextlib import contextmanager
from datetime import datetime

# --- Mapa opcional: timeframe -> rótulo legível ---
TIMEFRAME_MAP = {
    mt5.TIMEFRAME_M1: "1 Minuto",
    mt5.TIMEFRAME_M5: "5 Minutos",
    mt5.TIMEFRAME_M15: "15 Minutos",
    mt5.TIMEFRAME_M30: "30 Minutos",
    mt5.TIMEFRAME_H1: "1 Hora",
    mt5.TIMEFRAME_H4: "4 Horas",
    mt5.TIMEFRAME_D1: "Diário",
    mt5.TIMEFRAME_W1: "Semanal",
    mt5.TIMEFRAME_MN1: "Mensal",
}

@contextmanager
def mt5_connection():
    """Garante init/shutdown do MT5 com tratamento de erro."""
    if not mt5.initialize():
        raise RuntimeError(f"Falha ao inicializar MT5: {mt5.last_error()}")
    try:
        yield
    finally:
        mt5.shutdown()

def _normalize_df(rates) -> pd.DataFrame:
    """Converte retorno do MT5 em DataFrame padronizado."""
    if rates is None or len(rates) == 0:
        raise ValueError("Nenhum dado retornado pelo MT5.")
    df = pd.DataFrame(rates)
    # converter timestamp e normalizar colunas
    if "time" in df.columns:
        df["time"] = pd.to_datetime(df["time"], unit="s")
    # remover colunas não essenciais (se existirem)
    for col in ["spread", "tick_volume", "real_volume"]:
        if col in df.columns:
            df.drop(columns=col, inplace=True)
    # garantir tipos numéricos
    for col in ["open","high","low","close","volume"]:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")
    # ordenar e setar índice (opcional)
    df.sort_values("time", inplace=True)
    df.reset_index(drop=True, inplace=True)
    return df[["time","open","high","low","close","volume"]]

def _ensure_symbol(symbol: str):
    """Garante que o símbolo está visível/assinável no MT5."""
    info = mt5.symbol_info(symbol)
    if info is None:
        raise ValueError(f"Símbolo '{symbol}' não encontrado no MT5.")
    if not info.visible:
        if not mt5.symbol_select(symbol, True):
            raise RuntimeError(f"Não foi possível selecionar '{symbol}' no MT5.")

def fetch_mt5_by_range(symbol: str, timeframe: int, start: datetime, end: datetime) -> pd.DataFrame:
    """
    Coleta candles do MT5 por intervalo de datas [start, end).
    Retorna DataFrame com colunas: time, open, high, low, close, volume.
    """
    with mt5_connection():
        _ensure_symbol(symbol)
        rates = mt5.copy_rates_range(symbol, timeframe, start, end)
    return _normalize_df(rates)

def fetch_mt5_last_n(symbol: str, timeframe: int, n: int = 500) -> pd.DataFrame:
    """
    Coleta os últimos N candles disponíveis no MT5.
    Útil para atualizações rápidas/tempo real.
    """
    if n <= 0:
        raise ValueError("n deve ser > 0")
    with mt5_connection():
        _ensure_symbol(symbol)
        rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n)
    return _normalize_df(rates)

# ----------------- EXEMPLOS DE USO -----------------
if __name__ == "__main__":
    SYMBOL    = "BTCUSD-T"          # ajuste conforme o corretor
    TIMEFRAME = mt5.TIMEFRAME_M1
    START     = datetime(2025, 8, 2)
    END       = datetime(2025, 8, 12)

    # 1) Histórico por intervalo:
    try:
        df_hist = fetch_mt5_by_range(SYMBOL, TIMEFRAME, START, END)
        print("Histórico (head):")
        print(df_hist.head())
    except Exception as e:
        print("Erro ao buscar por intervalo:", e)

    # 2) Últimos N candles:
    try:
        df_last = fetch_mt5_last_n(SYMBOL, TIMEFRAME, n=1000)
        print("Últimos N (head):")
        print(df_last.head())
    except Exception as e:
        print("Erro ao buscar últimos N:", e)
Integração no app

Exponha no UI as opções:

Fonte de dados: “MetaTrader 5” (ou outras fontes já existentes).

Símbolo (ex.: BTCUSD-T, WIN$, etc.).

Timeframe (usar constantes do MT5, exibindo rótulos de TIMEFRAME_MAP).

Modo de coleta: “Intervalo de datas” (start/end) ou “Últimos N”.

Garanta que o retorno seja sempre um DataFrame com o mesmo esquema (time, open, high, low, close, volume) para facilitar o restante do pipeline (indicadores, sinais, gráficos, execução).

Boas práticas

Validar que START < END e que há candles no período.

Tratar fuso horário se for cruzar com outras fontes.

Repetir a coleta (via fetch_mt5_last_n) em intervalos fixos quando estivermos em um painel ao vivo.

Logar erros com detalhes de mt5.last_error() quando aplicável.

