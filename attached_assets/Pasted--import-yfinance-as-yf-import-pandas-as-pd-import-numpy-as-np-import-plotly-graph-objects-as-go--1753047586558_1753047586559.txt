
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots



# ======================= INPUTS DO USUÁRIO =======================
symbol = input("Digite o símbolo do ativo (ex: BTC-USD, PETR4.SA): ").strip()
start_date = input("Digite a data inicial (formato YYYY-MM-DD): ").strip()
end_date = input("Digite a data final (formato YYYY-MM-DD): ").strip()
interval = input("Digite o intervalo (ex: 1d, 1h, 5m): ").strip()
# ================================================================

# Obter dados
# Obter dados
df = yf.download(symbol, start=start_date, end=end_date, interval=interval)
df = df.xs(symbol,level='Ticker',axis=1)

# Ajustes
symbol_label = symbol.replace("=X", "")
df.reset_index(inplace=True)
df.rename(columns={"Datetime": "time", "Date": "time", "Open": "open", "High": "high", "Low": "low", "Close": "close"}, inplace=True)


# Parâmetro para confirmação de sinal
confirm_candles = 0  # Número de candles consecutivos com o mesmo sinal necessários para validação

# Cálculo das médias móveis
df['SMA_60'] = df['close'].rolling(window=60).mean()
df['SMA_70'] = df['close'].rolling(window=70).mean()
df['SMA_20'] = df['close'].rolling(window=20).mean()

# RSI de 14 períodos
delta = df['close'].diff()
gain = np.where(delta > 0, delta, 0)
loss = np.where(delta < 0, -delta, 0)
avg_gain = pd.Series(gain, index=df.index).rolling(window=14).mean()
avg_loss = pd.Series(loss, index=df.index).rolling(window=14).mean()
rs = avg_gain / avg_loss
df['RSI_14'] = 100 - (100 / (1 + rs))

# RSL (Relative Strength Levy) de 20 períodos
df['RSL_20'] = df['close'] / df['SMA_20']

# Condições combinadas
df['Signal'] = 'Stay Out'
for i in range(1, len(df)):
    rsi_up = df['RSI_14'].iloc[i] > df['RSI_14'].iloc[i-1]
    rsi_down = df['RSI_14'].iloc[i] < df['RSI_14'].iloc[i-1]
    rsl = df['RSL_20'].iloc[i]
    rsl_prev = df['RSL_20'].iloc[i-1]

    rsl_buy = (rsl > 1 and rsl > rsl_prev) or (rsl < 1 and rsl > rsl_prev)
    rsl_sell = (rsl > 1 and rsl < rsl_prev) or (rsl < 1 and rsl < rsl_prev)

    if (
        df['close'].iloc[i] > df['SMA_60'].iloc[i]
        and df['close'].iloc[i] > df['SMA_70'].iloc[i]
        and rsi_up and rsl_buy
    ):
        df.at[i, 'Signal'] = 'Buy'
    elif (
        df['close'].iloc[i] < df['SMA_60'].iloc[i]
        and rsi_down and rsl_sell
    ):
        df.at[i, 'Signal'] = 'Sell'

# Estado persistente com filtro de confirmação
df['Estado'] = 'Stay Out'
for i in range(confirm_candles, len(df)):
    # Verifica se os últimos N sinais foram todos iguais
    last_signals = df['Signal'].iloc[i - confirm_candles:i]
    current_signal = df['Signal'].iloc[i]

    if all(last_signals == current_signal) and current_signal != 'Stay Out':
        df.loc[df.index[i], 'Estado'] = current_signal
    else:
        df.loc[df.index[i], 'Estado'] = df['Estado'].iloc[i - 1]

# ATR e múltiplos Stops com travamento unidirecional
df['prior_close'] = df['close'].shift(1)
df['tr1'] = df['high'] - df['low']
df['tr2'] = abs(df['high'] - df['prior_close'])
df['tr3'] = abs(df['low'] - df['prior_close'])
df['TR'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
df['ATR'] = df['TR'].rolling(window=14).mean()

# Inicializa os três tipos de Stop
df['Stop_Justo'] = np.nan
df['Stop_Balanceado'] = np.nan
df['Stop_Largo'] = np.nan

# Fatores ATR para cada tipo
fatores = {'Stop_Justo': 1.5, 'Stop_Balanceado': 2.0, 'Stop_Largo': 3.0}

for i in range(1, len(df)):
    estado = df['Estado'].iloc[i]
    close = df['close'].iloc[i]
    atr = df['ATR'].iloc[i]

    for stop_tipo, fator in fatores.items():
        stop_anterior = df[stop_tipo].iloc[i - 1]
        if estado == 'Buy':
            stop_atual = close - fator * atr
            df.loc[df.index[i], stop_tipo] = max(stop_anterior, stop_atual) if pd.notna(stop_anterior) else stop_atual
        elif estado == 'Sell':
            stop_atual = close + fator * atr
            df.loc[df.index[i], stop_tipo] = min(stop_anterior, stop_atual) if pd.notna(stop_anterior) else stop_atual


# Cores e indicador
df['Color'] = 'black'
df.loc[df['Estado'] == 'Buy', 'Color'] = 'blue'
df.loc[df['Estado'] == 'Sell', 'Color'] = 'red'
df['Indicator'] = df['Estado'].map({'Buy': 1, 'Sell': 0, 'Stay Out': 0.5})





titulo_grafico = f"LUBRA TRADING - {symbol_label} - Timeframe: {interval.upper()}"

fig = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.03,
    row_heights=[0.75, 0.25],
    subplot_titles=("", "Indicador de Sinais")
)

for i in range(len(df) - 1):
    fig.add_trace(go.Scatter(
        x=df['time'][i:i+2],
        y=df['close'][i:i+2],
        mode="lines",
        line=dict(color=df['Color'][i]),
        showlegend=False,
        hoverinfo="skip"
    ), row=1, col=1)

fig.add_trace(go.Scatter(
    x=df['time'],
    y=df['close'],
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),
    name='Preço de Fechamento',
    hovertemplate="Fechamento: %{y:.2f}<extra></extra>",
    showlegend=False
), row=1, col=1)

fig.add_trace(go.Scatter(
    x=df['time'],
    y=df['close'],
    mode='lines',
    line=dict(color='rgba(0,0,0,0)'),
    name='Preço de Fechamento',
    hovertemplate="Fechamento: %{y:.2f}<extra></extra>",
    showlegend=False
), row=2, col=1)

# Traços para os três tipos de Stop
fig.add_trace(go.Scatter(
    x=df['time'], y=df['Stop_Justo'],
    mode="lines", name="STOP Justo",
    line=dict(color="orange", width=1.2, dash="dot"),
    visible=True,
    legendgroup="stop", showlegend=True
), row=1, col=1)

fig.add_trace(go.Scatter(
    x=df['time'], y=df['Stop_Balanceado'],
    mode="lines", name="STOP Balanceado",
    line=dict(color="gray", width=1.5, dash="dot"),
    visible=True,
    legendgroup="stop", showlegend=True
), row=1, col=1)

fig.add_trace(go.Scatter(
    x=df['time'], y=df['Stop_Largo'],
    mode="lines", name="STOP Largo",
    line=dict(color="green", width=1.5, dash="dot"),
    visible=True,
    legendgroup="stop", showlegend=True
), row=1, col=1)


fig.add_trace(go.Scatter(
    x=df['time'],
    y=df['Indicator'],
    mode="lines",
    name="Indicador de Sinais",
    line=dict(color="blue", width=2),
    showlegend=False
), row=2, col=1)


fig.add_trace(go.Scatter(
    x=[None], y=[None], mode='lines',
    line=dict(color='black', width=2),
    name='Stay Out'
), row=1, col=1)


fig.add_shape(
    type="line",
    x0=df['time'].iloc[0],
    x1=df['time'].iloc[-1],
    y0=0.5,
    y1=0.5,
    line=dict(color="black", width=2, dash="dash"),
    xref="x", yref="y2"
)

fig.update_yaxes(range=[-0.1, 1.1], tickvals=[0, 0.5, 1], row=2, col=1)
fig.update_xaxes(showgrid=False, row=2, col=1)
fig.update_layout(
    shapes=[dict(
        type="rect",
        x0=df['time'].iloc[0],
        x1=df['time'].iloc[-1],
        y0=-0.1,
        y1=1.1,
        xref="x",
        yref="y2",
        fillcolor="rgba(173, 216, 230, 0.3)",
        line=dict(width=0)
    )],
    title=dict(text=titulo_grafico, x=0.5, font=dict(size=18)),
    template="plotly_white",
    hovermode="x unified",
    width=1100,
    height=750,
    updatemenus=[
        dict(
            buttons=list([
                dict(
                    args=[{"visible": [trace.name not in ["STOP Justo", "STOP Balanceado", "STOP Largo"] or trace.name == "STOP Justo" for trace in fig.data]}],
                    label="Stop Justo",
                    method="restyle"
                ),
                dict(
                    args=[{"visible": [trace.name not in ["STOP Justo", "STOP Balanceado", "STOP Largo"] or trace.name == "STOP Balanceado" for trace in fig.data]}],
                    label="Stop Balanceado",
                    method="restyle"
                ),
                dict(
                    args=[{"visible": [trace.name not in ["STOP Justo", "STOP Balanceado", "STOP Largo"] or trace.name == "STOP Largo" for trace in fig.data]}],
                    label="Stop Largo",
                    method="restyle"
                )
            ]),
            direction="down",
            showactive=True,
            x=0.01,
            xanchor="left",
            y=1.15,
            yanchor="top"
        )
    ]
)

fig.add_trace(go.Scatter(x=[None], y=[None], mode='lines', line=dict(color='blue', width=2), name='Compra'), row=1, col=1)
fig.add_trace(go.Scatter(x=[None], y=[None], mode='lines', line=dict(color='red', width=2), name='Venda'), row=1, col=1)

fig.show()


